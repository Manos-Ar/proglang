(*9.1:*)

val int_to_real = map real;

(*9.2:*)

val ord_list = map ord;

(*9.3:*)

val square_list = map (fn a => a*a);

(*9.4:*)

val mult_pairs = map (fn(a,b) => a*b);

(*9.5:*)

fun inc_list L c =
map (fn(a)=> a+c) L;

(*9.6:*)

val square_sum = foldr (fn(a,b)=>b+a*a) 0;

(*9.7:*)

fun list_or nil = false
| list_or L = foldr (fn(a,b)=>a orelse b) false L;

(*9.8:*)

fun list_and nil = true
| list_and L = foldr (fn(a,b)=>a andalso b) true L;

(*9.9:*)

fun list_xor nil = false
| list_xor L = foldr (fn(a,b)=>if a=b then false else true) false L;

(*9.10:*)

fun dup_list nil = nil
| dup_list L = foldr (fn(a,b)=>a::a::b) nil L;

(*9.11:*)

fun my_length nil = 0
| my_length L = foldr (fn(a,b)=>b+1) 0 L;

(*9.12:*)

fun abs_values nil = nil
| abs_values L = map (fn(a)=>if a<0 then real(~a) else real(a)) L;

(*9.13:*)

fun true_count nil = 0
| true_count L = foldr (fn(a,b)=>if a=true then b+1 else b) 0 L;

(*9.14:*)

fun max_pairs nil = nil
| max_pairs L = map (fn(a,b)=>if a<b then b else a) L;

(*9.15:*)

fun my_implode nil=""
| my_implode L = foldr (fn(a,b)=>str(a)^b) "" L;

(*9.16:*)

fun all_append nil = nil
| all_append L = foldr (fn(a,b)=>a@b) nil L;

(*9.17:*)

fun max L =
let
val SOME x = Int.minInt
in
foldr (fn(a,b)=> if a<b then b else a) x L
end;

(*9.18:*)

fun min L =
let
val SOME x = Int.maxInt
in
foldr (fn(a,b)=> if a>b then b else a) x L
end;

(*9.19:*)

fun member(e,nil)=false
| member(e,L) =
let
val li = map(fn(a) => a=e) L;
in
foldr (fn(a,b) => a orelse b) false li
end;

(*9.20:*)

fun append nil nil = nil
| append l1 l2 =
foldr (fn(a,b)=> a::b) l2 l1;

(*9.21:*)

fun less(e,nil) = nil
| less(e,L) =
foldr (fn(a,b) => if a<e then a::b else b) nil L;

(*9.22:*)

fun evens nil = nil
| evens L =
foldr(fn(a,b) => if a mod 2 = 0 then a::b else b) nil L;

(*9.23:*)

fun convert nil = (nil,nil)
| convert L =
foldr (fn((a,b),(c,d))=> (a::c,b::d)) (nil,nil) L;

(*9.24:*)

fun mymap f nil = nil
| mymap f L =
foldr (fn(a,b)=>f a::b) nil L;

(*fun evaluate nil x = 0.0
| evaluate L x =
if x>=0.0 andalso x<=0.0 then hd(L)
else
let val k = x in foldl(fn(a,b)=>
let
val m = m*k
in
b+a*m/k
end; )
0.0 L
end;*)

(*9.26:*)

fun my_map f nil = nil
| my_map f (a::more) =
f(a)::(my_map f more);

(*9.27:*)

